{"version":3,"sources":["../../src/core/flashcore.ts"],"names":["FlashcoreFileAdapter","Globals","logger","_initialized","_watchers","Flashcore","key","options","oldValue","callback","value","setValue","resolvedOldValue","newValue","keyvOptions","Keyv","error","keyv","adapter"],"mappings":"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","sourcesContent":["import { FlashcoreFileAdapter } from './flashcore-fs.js'\nimport { Globals } from './globals.js'\nimport { logger } from './logger.js'\nimport type { FlashcoreAdapter } from '../types/index.js'\nimport type KeyvType from 'keyv'\n\n// Make sure it's initialized just once\nlet _initialized = false\n\n// Watchers for listening to changes in the store.\nconst _watchers = new Map<string, Set<WatcherCallback>>()\n\n// Type definitions\ninterface FlashcoreOptions {\n\tnamespace?: string | Array<string>\n}\ninterface InitFlashcoreOptions {\n\tadapter?: FlashcoreAdapter\n\tkeyvOptions?: unknown\n}\ntype WatcherCallback<V = unknown> = (oldValue: V, newValue: V) => void | Promise<void>\n\n/**\n * Built-in KV database for long-term storage.\n *\n * ```ts\n * import { Flashcore } from 'robo.js'\n *\n * await Flashcore.set('key', 'value')\n * const value = await Flashcore.get('key')\n * await Flashcore.delete('key')\n * ```\n *\n * Use this to store and retrieve data across sessions. All APIs are asynchronous.\n * Defaults to file-based storage, but can be configured to use other engines using Keyv adapters.\n *\n * [**Learn more:** Flashcore Database](https://robojs.dev/robojs/flashcore)\n */\nexport const Flashcore = {\n\t/**\n\t * Clears all key-value pairs from the store.\n\t *\n\t * @returns {Promise<boolean> | boolean} - Resolves to a boolean indicating whether the operation was successful.\n\t */\n\tclear: (): Promise<boolean> | Promise<void> | boolean | void => {\n\t\treturn Globals.getFlashcoreAdapter().clear()\n\t},\n\n\t/**\n\t * Deletes the value associated with a key from the store.\n\t *\n\t * @param {string} key - The key associated with the value to delete.\n\t * @returns {Promise<boolean> | boolean} - Resolves to a boolean indicating whether the operation was successful.\n\t */\n\tdelete: (key: string, options?: FlashcoreOptions): Promise<boolean> | boolean => {\n\t\t// If a namespace is provided, prepend it to the key\n\t\tif (options?.namespace) {\n\t\t\tkey = Array.isArray(options.namespace) ? `${options.namespace.join('/')}__${key}` : `${options.namespace}__${key}`\n\t\t}\n\n\t\tif (_watchers.has(key)) {\n\t\t\tconst oldValue = Globals.getFlashcoreAdapter().get(key)\n\t\t\tif (oldValue instanceof Promise) {\n\t\t\t\t// Return as promise to avoid race condition fetching the old value.\n\t\t\t\t// I believe this is ideal, as promise-based values are likely to be used with async/await.\n\t\t\t\treturn oldValue\n\t\t\t\t\t.then((oldValue) => {\n\t\t\t\t\t\t_watchers.get(key).forEach((callback) => callback(oldValue, undefined))\n\t\t\t\t\t})\n\t\t\t\t\t.then(() => Globals.getFlashcoreAdapter().delete(key))\n\t\t\t\t\t.catch(() => Globals.getFlashcoreAdapter().delete(key))\n\t\t\t} else {\n\t\t\t\t_watchers.get(key).forEach((callback) => callback(oldValue, undefined))\n\t\t\t}\n\t\t}\n\n\t\treturn Globals.getFlashcoreAdapter().delete(key)\n\t},\n\n\t/**\n\t * Gets the value associated with a key.\n\t *\n\t * @template V - The type of the value.\n\t * @param {string} key - The key associated with the value.\n\t * @returns {Promise<V> | V} - May return a promise you can await or the value directly.\n\t */\n\tget: <V>(key: string, options?: FlashcoreOptions & { default?: unknown }): Promise<V> | V => {\n\t\t// If a namespace is provided, prepend it to the key\n\t\tif (options?.namespace) {\n\t\t\tkey = Array.isArray(options.namespace) ? `${options.namespace.join('/')}__${key}` : `${options.namespace}__${key}`\n\t\t}\n\n\t\treturn (Globals.getFlashcoreAdapter().get(key) ?? options?.default) as V\n\t},\n\n\t/**\n\t * Checks if a key exists in the store.\n\t *\n\t * @param key - The key to check.\n\t * @param options  - Options for the operation.\n\t * @returns - A boolean indicating whether the key exists.\n\t */\n\thas: (key: string, options?: FlashcoreOptions): Promise<boolean> | boolean => {\n\t\tif (options?.namespace) {\n\t\t\tkey = `${options.namespace}__${key}`\n\t\t}\n\t\treturn Globals.getFlashcoreAdapter().has(key)\n\t},\n\n\t/**\n\t * Unregisters a callback from a key, so it will no longer be executed when the key's value changes.\n\t *\n\t * @param {string} key - The key to stop watching.\n\t * @param {WatcherCallback} callback - The callback function to remove from the key's watch list.\n\t * If no callback is provided, all callbacks associated with the key are removed.\n\t */\n\toff: (key: string, callback?: WatcherCallback, options?: FlashcoreOptions) => {\n\t\t// If a namespace is provided, prepend it to the key\n\t\tif (options?.namespace) {\n\t\t\tkey = Array.isArray(options.namespace) ? `${options.namespace.join('/')}__${key}` : `${options.namespace}__${key}`\n\t\t}\n\n\t\tif (_watchers.has(key) && callback) {\n\t\t\t_watchers.get(key)?.delete(callback)\n\n\t\t\tif (_watchers.get(key)?.size === 0) {\n\t\t\t\t_watchers.delete(key)\n\t\t\t}\n\t\t} else if (_watchers.has(key)) {\n\t\t\t_watchers.delete(key)\n\t\t}\n\t},\n\n\t/**\n\t * Registers a callback to be executed when a specific key's value changes in the store.\n\t *\n\t * @template V - The type of the value.\n\t * @param {string} key - The key to watch for changes.\n\t * @param {WatcherCallback} callback - The callback function to execute when the key's value changes.\n\t * The callback receives the new and old values as arguments.\n\t */\n\ton: (key: string, callback: WatcherCallback, options?: FlashcoreOptions) => {\n\t\t// If a namespace is provided, prepend it to the key\n\t\tif (options?.namespace) {\n\t\t\tkey = Array.isArray(options.namespace) ? `${options.namespace.join('/')}__${key}` : `${options.namespace}__${key}`\n\t\t}\n\n\t\tif (!_watchers.has(key)) {\n\t\t\t_watchers.set(key, new Set())\n\t\t}\n\n\t\t_watchers.get(key)?.add(callback)\n\t},\n\n\t/**\n\t * Sets a key-value pair in the store.\n\t *\n\t * @template V - The type of the value.\n\t * @param {string} key - The key to associate with the value.\n\t * @param {V} value - The value to set.\n\t * @returns {Promise<boolean> | boolean} - Resolves to a boolean indicating whether the operation was successful.\n\t */\n\tset: <V>(key: string, value: V, options?: FlashcoreOptions): Promise<boolean> | boolean => {\n\t\t// If a namespace is provided, prepend it to the key\n\t\tif (options?.namespace) {\n\t\t\tkey = Array.isArray(options.namespace) ? `${options.namespace.join('/')}__${key}` : `${options.namespace}__${key}`\n\t\t}\n\n\t\tif (_watchers.has(key) || typeof value === 'function') {\n\t\t\t// Fetch the old value only when necessary for minimal overhead\n\t\t\tconst oldValue: unknown = Globals.getFlashcoreAdapter().get(key)\n\n\t\t\tconst setValue = async (resolvedOldValue: V) => {\n\t\t\t\tlet newValue = value\n\n\t\t\t\t// If value is an updater function, use it to compute the new value based on the old value\n\t\t\t\tif (typeof value === 'function') {\n\t\t\t\t\tnewValue = (value as (oldValue: V) => V)(resolvedOldValue as V)\n\t\t\t\t}\n\n\t\t\t\t// Run the watcher callbacks if any are set for this key\n\t\t\t\tif (_watchers.has(key)) {\n\t\t\t\t\t_watchers.get(key).forEach((callback) => callback(resolvedOldValue, newValue))\n\t\t\t\t}\n\n\t\t\t\t// Set the new value in the adapter\n\t\t\t\treturn Globals.getFlashcoreAdapter().set(key, newValue)\n\t\t\t}\n\n\t\t\t// If the old value is a promise, wait for it to resolve before proceeding\n\t\t\tif (oldValue instanceof Promise) {\n\t\t\t\t// Return as promise to avoid race condition fetching the old value.\n\t\t\t\t// I believe this is ideal, as promise-based values are likely to be used with async/await.\n\t\t\t\treturn oldValue\n\t\t\t\t\t.then(async (resolvedOldValue) => await setValue(resolvedOldValue))\n\t\t\t\t\t.catch(() => Globals.getFlashcoreAdapter().set(key, value)) // Fallback to set the value directly in case of an error\n\t\t\t} else {\n\t\t\t\treturn setValue(oldValue as V)\n\t\t\t}\n\t\t}\n\n\t\treturn Globals.getFlashcoreAdapter().set(key, value)\n\t},\n\n\t/**\n\t * Prepares Flashcore for usage.\n\t * This must be called before using any other Flashcore functions.\n\t *\n\t * Can only be called once per process.\n\t *\n\t * @param options - Options for initializing Flashcore, such as custom adapters.\n\t */\n\t$init: async (options: InitFlashcoreOptions) => {\n\t\tconst { keyvOptions } = options\n\t\tlogger.debug('Initializing Flashcore with options:', options)\n\n\t\t// Prevent multiple initializations\n\t\tif (_initialized) {\n\t\t\tlogger.debug('Flashcore has already been initialized. Ignoring...')\n\t\t\treturn\n\t\t}\n\n\t\ttry {\n\t\t\tif (keyvOptions) {\n\t\t\t\tlet Keyv: typeof KeyvType\n\t\t\t\ttry {\n\t\t\t\t\tKeyv = (await import('keyv')).default\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthrow new Error('Failed to import Keyv. Did you remember to install `keyv`?', { cause: error })\n\t\t\t\t}\n\t\t\t\tconst keyv = new Keyv(keyvOptions)\n\n\t\t\t\tkeyv.on('error', (error: unknown) => {\n\t\t\t\t\tlogger.error(`Keyv error:`, error)\n\t\t\t\t})\n\t\t\t\tGlobals.registerFlashcore(keyv)\n\t\t\t} else {\n\t\t\t\tconst adapter = options.adapter ?? new FlashcoreFileAdapter()\n\t\t\t\tawait adapter.init()\n\t\t\t\tGlobals.registerFlashcore(adapter)\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error('Failed to initialize Flashcore:', error)\n\t\t\tthrow new Error('Failed to initialize Flashcore', { cause: error })\n\t\t}\n\n\t\t_initialized = true\n\t}\n}\n"]}