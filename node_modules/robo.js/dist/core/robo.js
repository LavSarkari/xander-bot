import { color } from './color.js';
import { registerProcessEvents } from './process.js';
import { Compiler } from '../cli/utils/compiler.js';
import { Client, Events, Collection } from 'discord.js';
import { loadConfig, getConfig } from './config.js';
import { discordLogger, FLASHCORE_KEYS } from './constants.js';
import { logger } from './logger.js';
import { env, Env } from './env.js';
import { executeEventHandler, executeCommandHandler, executeAutocompleteHandler, executeContextHandler } from './handlers.js';
import { PackageDir, hasProperties } from '../cli/utils/utils.js';
import { Nanocore } from '../internal/nanocore.js';
import { Flashcore } from './flashcore.js';
import { Mode } from './mode.js';
import { loadState } from './state.js';
import C from './portal.js';
import W from 'node:path';
import { isMainThread, parentPort } from 'node:worker_threads';

const wt={restart:U,start:q,stop:Q,build:Y};let i;const L=new C;let R;async function Y(e){const{buildAction:o}=await import('../cli/commands/build/index.js');await o([],{exit:!1,...e??{}});}async function q(e){const o=process.pid,r=String(process.env.ROBO_INSTANCE_ID??o);try{const{client:c,logLevel:w,shard:m,stateLoad:y}=e??{};registerProcessEvents();const[s]=await Promise.all([loadConfig(),Compiler.useManifest()]);if(logger({drain:s?.logger?.drain,enabled:s?.logger?.enabled,level:w??s?.logger?.level}).debug("Starting Robo..."),m&&s.experimental?.disableBot!==!0){discordLogger.debug("Sharding is enabled. Delegating start to shard manager...");const{ShardingManager:t}=await import('discord.js'),a=typeof m=="string"?m:W.join(PackageDir,"dist","cli","shard.js"),d=typeof s.experimental?.shard=="object"?s.experimental.shard:{},h=new t(a,{...d,token:env.get("discord.token")});h.on("shardCreate",k=>discordLogger.debug("Launched shard",k.id));const P=await h.spawn();discordLogger.debug("Spawned",P.size,"shard(s)");return}const D=Mode.get();if(await Env.load({mode:D}),await Flashcore.$init({keyvOptions:s.flashcore?.keyv}),y)logger.debug("Waiting for state..."),await y;else {const t=Date.now(),a=await Flashcore.get(FLASHCORE_KEYS.state);a&&loadState(a),logger.debug(`State loaded in ${Date.now()-t}ms`);}const b=V();if(s.experimental?.disableBot!==!0?i=c??new Client(s.clientOptions):logger.debug("Bot is disabled, skipping client setup..."),await C.open(),await Nanocore.set("watch",{id:r,pid:o,startedAt:Date.now(),status:"running"}),await executeEventHandler(b,"_start",i),s.experimental?.disableBot!==!0){for(const t of L.events.keys()){const a=L.events.get(t).every(d=>d.auto);i.on(t,async(...d)=>{a||discordLogger.event(`Event received: ${color.bold(t)}`),discordLogger.trace("Event args:",d),executeEventHandler(b,t,...d);});}i.on(Events.InteractionCreate,async t=>{if(t.isChatInputCommand()){const a=A(t);discordLogger.event(`Received slash command interaction: ${color.bold("/"+a)}`),discordLogger.trace("Slash command interaction:",t.toJSON()),await executeCommandHandler(t,a);}else if(t.isAutocomplete()){const a=A(t);discordLogger.event(`Received autocomplete interaction for: ${color.bold(t.commandName)}`),discordLogger.trace("Autocomplete interaction:",t.toJSON()),await executeAutocompleteHandler(t,a);}else t.isContextMenuCommand()&&(discordLogger.event(`Received context menu interaction: ${color.bold(t.commandName)}`),discordLogger.trace("Context menu interaction:",t.toJSON()),await executeContextHandler(t,t.commandName));}),await i.login(env.get("discord.token"));}}catch(c){throw await Nanocore.update("watch",{id:r,status:"attention"}),c}}async function Q(e=0){await Nanocore.update("watch",{status:e===0?"stopping":"error"});try{await executeEventHandler(R,"_stop",i),i?.destroy(),logger.debug("Stopped Robo at "+new Date().toLocaleString()),e===0&&await Nanocore.update("watch",{status:"stopped"});}finally{isMainThread||(await logger.flush(),parentPort?.postMessage({event:"stop",payload:"exit"}),parentPort?.close()),process.exit(e);}}async function U(){try{await executeEventHandler(R,"_restart",i),i?.destroy(),logger.debug("Restarted Robo at "+new Date().toLocaleString());}finally{isMainThread?process.exit(0):(await Nanocore.update("watch",{status:"restarting"}),await logger.flush(),parentPort?.postMessage({event:"stop",payload:"exit"}),parentPort?.close(),process.exit());}}function A(e){const o=[e.commandName];if(hasProperties(e.options,["getSubcommandGroup"]))try{o.push(e.options.getSubcommandGroup());}catch{}if(hasProperties(e.options,["getSubcommand"]))try{o.push(e.options.getSubcommand());}catch{}return o.filter(Boolean).join(" ")}function V(){const e=getConfig(),o=new Collection;if(!e.plugins)return o;for(const r of e.plugins)if(typeof r=="string")o.set(r,{name:r});else if(Array.isArray(r)){const[c,w,m]=r;o.set(c,{name:c,options:w,metaOptions:m});}return o}

export { wt as Robo, Y as build, i as client, L as portal };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=robo.js.map