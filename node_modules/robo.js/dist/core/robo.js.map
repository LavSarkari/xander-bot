{"version":3,"sources":["../../src/core/robo.ts"],"names":["color","registerProcessEvents","Compiler","Client","Collection","Events","getConfig","loadConfig","FLASHCORE_KEYS","discordLogger","logger","env","Env","executeAutocompleteHandler","executeCommandHandler","executeContextHandler","executeEventHandler","hasProperties","PackageDir","Nanocore","Flashcore","Mode","loadState","Portal","path","isMainThread","parentPort","Robo","restart","start","stop","build","client","portal","plugins","options","buildAction","pid","id","optionsClient","logLevel","shard","stateLoad","config","ShardingManager","shardPath","manager","result","mode","stateStart","state","loadPluginData","key","onlyAuto","event","args","interaction","commandKey","getCommandKey","error","exitCode","commandKeys","collection","plugin","name","metaOptions"],"mappings":"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","sourcesContent":["import { color } from './color.js'\nimport { registerProcessEvents } from './process.js'\nimport { Compiler } from '../cli/utils/compiler.js'\nimport { Client, Collection, Events } from 'discord.js'\nimport { getConfig, loadConfig } from './config.js'\nimport { FLASHCORE_KEYS, discordLogger } from './constants.js'\nimport { logger, LogLevel } from './logger.js'\nimport { env, Env } from './env.js'\nimport {\n\texecuteAutocompleteHandler,\n\texecuteCommandHandler,\n\texecuteContextHandler,\n\texecuteEventHandler\n} from './handlers.js'\nimport { hasProperties, PackageDir } from '../cli/utils/utils.js'\nimport { Nanocore } from '../internal/nanocore.js'\nimport { Flashcore } from './flashcore.js'\nimport { Mode } from './mode.js'\nimport { loadState } from './state.js'\nimport Portal from './portal.js'\nimport path from 'node:path'\nimport { isMainThread, parentPort } from 'node:worker_threads'\nimport type { HandlerRecord, PluginData } from '../types/index.js'\nimport type { AutocompleteInteraction, CommandInteraction } from 'discord.js'\nimport type { BuildCommandOptions } from '../cli/commands/build/index.js'\n\n/**\n * Robo is the main entry point for your bot. It provides a simple API for starting, stopping, and restarting your Robo.\n *\n * ```ts\n * import { Robo } from 'robo.js'\n *\n * Robo.start()\n * ```\n *\n * You do not normally need to use this API directly, as the CLI will handle starting and stopping for you.\n *\n * [**Learn more:** Robo](https://robojs.dev/discord-bots/migrate)\n */\nexport const Robo = { restart, start, stop, build }\n\n// Each Robo instance has its own client, exported for convenience\nexport let client: Client\n\n// A Portal is exported with each Robo to allow for dynamic controls\nexport const portal = new Portal()\n\n// Be careful, plugins may contain sensitive data in their config\nlet plugins: Collection<string, PluginData>\n\ninterface StartOptions {\n\tclient?: Client\n\tlogLevel?: LogLevel\n\tshard?: string | boolean\n\tstateLoad?: Promise<void>\n}\n\ntype BuildOptions = BuildCommandOptions\n\n/**\n * Builds your Robo instance. Similar to running `robo build` from the CLI.\n *\n * @param options - Options for building your Robo instance, similar to CLI options\n * @returns A promise that resolves when Robo has finished building\n */\nexport async function build(options?: BuildOptions) {\n\tconst { buildAction } = await import('../cli/commands/build/index.js')\n\tawait buildAction([], {\n\t\texit: false,\n\t\t...(options ?? {})\n\t})\n}\n\n/**\n * Starts your Robo instance. Similar to running `robo start` from the CLI.\n *\n * @param options - Options for starting your Robo instance\n * @returns A promise that resolves when Robo has started\n */\nasync function start(options?: StartOptions) {\n\tconst pid = process.pid\n\tconst id = String(process.env.ROBO_INSTANCE_ID ?? pid)\n\n\ttry {\n\t\tconst { client: optionsClient, logLevel, shard, stateLoad } = options ?? {}\n\n\t\t// Important! Register process events before doing anything else\n\t\t// This ensures the \"ready\" signal is sent to the parent process\n\t\tregisterProcessEvents()\n\n\t\t// Load config and manifest up next!\n\t\t// This makes them available globally via getConfig() and getManifest()\n\t\tconst [config] = await Promise.all([loadConfig(), Compiler.useManifest()])\n\t\tlogger({\n\t\t\tdrain: config?.logger?.drain,\n\t\t\tenabled: config?.logger?.enabled,\n\t\t\tlevel: logLevel ?? config?.logger?.level\n\t\t}).debug('Starting Robo...')\n\n\t\t// Wanna shard? Delegate to the shard manager and await recursive call\n\t\tif (shard && config.experimental?.disableBot !== true) {\n\t\t\tdiscordLogger.debug('Sharding is enabled. Delegating start to shard manager...')\n\t\t\tconst { ShardingManager } = await import('discord.js')\n\t\t\tconst shardPath = typeof shard === 'string' ? shard : path.join(PackageDir, 'dist', 'cli', 'shard.js')\n\t\t\tconst options = typeof config.experimental?.shard === 'object' ? config.experimental.shard : {}\n\t\t\tconst manager = new ShardingManager(shardPath, { ...options, token: env.get('discord.token') })\n\n\t\t\tmanager.on('shardCreate', (shard) => discordLogger.debug(`Launched shard`, shard.id))\n\t\t\tconst result = await manager.spawn()\n\t\t\tdiscordLogger.debug('Spawned', result.size, 'shard(s)')\n\t\t\treturn\n\t\t}\n\n\t\tconst mode = Mode.get()\n\t\tawait Env.load({ mode })\n\t\tawait Flashcore.$init({ keyvOptions: config.flashcore?.keyv })\n\n\t\t// Wait for states to be loaded\n\t\tif (stateLoad) {\n\t\t\t// Await external state promise if provided\n\t\t\tlogger.debug('Waiting for state...')\n\t\t\tawait stateLoad\n\t\t} else {\n\t\t\t// Load state directly otherwise\n\t\t\tconst stateStart = Date.now()\n\t\t\tconst state = await Flashcore.get<Record<string, unknown>>(FLASHCORE_KEYS.state)\n\n\t\t\tif (state) {\n\t\t\t\tloadState(state)\n\t\t\t}\n\t\t\tlogger.debug(`State loaded in ${Date.now() - stateStart}ms`)\n\t\t}\n\n\t\t// Load plugin options\n\t\tconst plugins = loadPluginData()\n\n\t\t// Create the new client instance (unless disabled)\n\t\tif (config.experimental?.disableBot !== true) {\n\t\t\tclient = optionsClient ?? new Client(config.clientOptions)\n\t\t} else {\n\t\t\tlogger.debug(`Bot is disabled, skipping client setup...`)\n\t\t}\n\n\t\t// Load the portal (commands, context, events)\n\t\tawait Portal.open()\n\n\t\t// Let external watchers know we're ready to go\n\t\tawait Nanocore.set('watch', { id, pid, startedAt: Date.now(), status: 'running' })\n\n\t\t// Notify lifecycle event handlers\n\t\tawait executeEventHandler(plugins, '_start', client)\n\n\t\tif (config.experimental?.disableBot !== true) {\n\t\t\t// Define event handlers\n\t\t\tfor (const key of portal.events.keys()) {\n\t\t\t\tconst onlyAuto = portal.events.get(key).every((event: HandlerRecord<Event>) => event.auto)\n\t\t\t\tclient.on(key, async (...args) => {\n\t\t\t\t\tif (!onlyAuto) {\n\t\t\t\t\t\tdiscordLogger.event(`Event received: ${color.bold(key)}`)\n\t\t\t\t\t}\n\t\t\t\t\tdiscordLogger.trace('Event args:', args)\n\n\t\t\t\t\t// Notify event handler\n\t\t\t\t\texecuteEventHandler(plugins, key, ...args)\n\t\t\t\t})\n\t\t\t}\n\n\t\t\t// Forward command interactions to our fancy handlers\n\t\t\tclient.on(Events.InteractionCreate, async (interaction) => {\n\t\t\t\tif (interaction.isChatInputCommand()) {\n\t\t\t\t\tconst commandKey = getCommandKey(interaction)\n\t\t\t\t\tdiscordLogger.event(`Received slash command interaction: ${color.bold('/' + commandKey)}`)\n\t\t\t\t\tdiscordLogger.trace('Slash command interaction:', interaction.toJSON())\n\t\t\t\t\tawait executeCommandHandler(interaction, commandKey)\n\t\t\t\t} else if (interaction.isAutocomplete()) {\n\t\t\t\t\tconst commandKey = getCommandKey(interaction)\n\t\t\t\t\tdiscordLogger.event(`Received autocomplete interaction for: ${color.bold(interaction.commandName)}`)\n\t\t\t\t\tdiscordLogger.trace('Autocomplete interaction:', interaction.toJSON())\n\t\t\t\t\tawait executeAutocompleteHandler(interaction, commandKey)\n\t\t\t\t} else if (interaction.isContextMenuCommand()) {\n\t\t\t\t\tdiscordLogger.event(`Received context menu interaction: ${color.bold(interaction.commandName)}`)\n\t\t\t\t\tdiscordLogger.trace('Context menu interaction:', interaction.toJSON())\n\t\t\t\t\tawait executeContextHandler(interaction, interaction.commandName)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t// Log in to Discord with your client's token\n\t\t\tawait client.login(env.get('discord.token'))\n\t\t}\n\t} catch (error) {\n\t\tawait Nanocore.update('watch', { id, status: 'attention' })\n\t\tthrow error\n\t}\n}\n\n/**\n * Stops your Robo instance gracefully. Similar to pressing `Ctrl+C` in the terminal.\n *\n * @param exitCode - The exit code to use when stopping Robo\n */\nasync function stop(exitCode = 0) {\n\tawait Nanocore.update('watch', { status: exitCode === 0 ? 'stopping' : 'error' })\n\n\ttry {\n\t\t// Notify lifecycle handler\n\t\tawait executeEventHandler(plugins, '_stop', client)\n\t\tclient?.destroy()\n\t\tlogger.debug(`Stopped Robo at ` + new Date().toLocaleString())\n\n\t\tif (exitCode === 0) {\n\t\t\tawait Nanocore.update('watch', { status: 'stopped' })\n\t\t}\n\t} finally {\n\t\tif (isMainThread) {\n\t\t\tprocess.exit(exitCode)\n\t\t} else {\n\t\t\tawait logger.flush()\n\t\t\tparentPort?.postMessage({ event: 'stop', payload: 'exit' })\n\t\t\tparentPort?.close()\n\t\t\tprocess.exit(exitCode)\n\t\t}\n\t}\n}\n\n/**\n * Restarts your Robo instance gracefully. Similar to making changes with `robo dev` and restarting.\n *\n * @returns A promise that resolves when Robo has restarted\n */\nasync function restart() {\n\ttry {\n\t\t// Notify lifecycle handler\n\t\tawait executeEventHandler(plugins, '_restart', client)\n\t\tclient?.destroy()\n\t\tlogger.debug(`Restarted Robo at ` + new Date().toLocaleString())\n\t} finally {\n\t\tif (isMainThread) {\n\t\t\tprocess.exit(0)\n\t\t} else {\n\t\t\tawait Nanocore.update('watch', { status: 'restarting' })\n\t\t\tawait logger.flush()\n\t\t\tparentPort?.postMessage({ event: 'stop', payload: 'exit' })\n\t\t\tparentPort?.close()\n\t\t\tprocess.exit()\n\t\t}\n\t}\n}\n\nfunction getCommandKey(interaction: AutocompleteInteraction | CommandInteraction) {\n\tconst commandKeys = [interaction.commandName]\n\tif (hasProperties<{ getSubcommandGroup: () => string }>(interaction.options, ['getSubcommandGroup'])) {\n\t\ttry {\n\t\t\tcommandKeys.push(interaction.options.getSubcommandGroup())\n\t\t} catch {\n\t\t\t// Ignore\n\t\t}\n\t}\n\tif (hasProperties<{ getSubcommand: () => string }>(interaction.options, ['getSubcommand'])) {\n\t\ttry {\n\t\t\tcommandKeys.push(interaction.options.getSubcommand())\n\t\t} catch {\n\t\t\t// Ignore\n\t\t}\n\t}\n\treturn commandKeys.filter(Boolean).join(' ')\n}\n\nfunction loadPluginData() {\n\tconst config = getConfig()\n\tconst collection = new Collection<string, PluginData>()\n\tif (!config.plugins) {\n\t\treturn collection\n\t}\n\n\tfor (const plugin of config.plugins) {\n\t\tif (typeof plugin === 'string') {\n\t\t\tcollection.set(plugin, { name: plugin })\n\t\t} else if (Array.isArray(plugin)) {\n\t\t\tconst [name, options, metaOptions] = plugin\n\t\t\tcollection.set(name, { name, options, metaOptions })\n\t\t}\n\t}\n\n\treturn collection\n}\n"]}