{"version":3,"sources":["../../src/core/flashcore-fs.ts"],"names":["fs","path","pipeline","zlib","createReadStream","createWriteStream","logger","hasProperties","createHash","FlashcoreFileAdapter","options","key","fileName","_getSafeKey","e","gunzip","decompressed","value","gzip"],"mappings":"AAAA,OAAOA,MAAQ,mBACf,OAAOC,MAAU,YACjB,OAAS,YAAAC,MAAgB,uBACzB,OAAOC,MAAU,YACjB,OAAS,oBAAAC,EAAkB,qBAAAC,MAAyB,UACpD,OAAS,UAAAC,MAAc,cACvB,OAAS,iBAAAC,MAAqB,wBAC9B,OAAS,cAAAC,MAAkB,cAOpB,MAAMC,CAAgF,CAC5E,QAEhB,YAAYC,EAAuC,CAAC,EAAG,CACtD,KAAK,QAAUA,EAAQ,SAAWT,EAAK,KAAK,QAAQ,IAAI,EAAG,QAAS,MAAM,CAC3E,CAEA,MAAa,OAA0B,CACtC,GAAI,CACH,aAAMD,EAAG,GAAG,KAAK,QAAS,CAAE,UAAW,GAAM,MAAO,EAAK,CAAC,EAC1D,MAAMA,EAAG,MAAM,KAAK,QAAS,CAAE,UAAW,EAAK,CAAC,EACzC,EACR,MAAE,CACD,MAAO,EACR,CACD,CAEA,MAAa,OAAOW,EAA0B,CAC7C,GAAI,CACH,MAAMC,EAAWX,EAAK,KAAK,KAAK,QAASY,EAAYF,CAAG,CAAC,EACzD,aAAMX,EAAG,OAAOY,CAAQ,EACjB,EACR,OAASE,EAAP,CAED,OAAIP,EAAiCO,EAAG,CAAC,MAAM,CAAC,GAAKA,EAAE,OAAS,UAC/DR,EAAO,KAAK,yBAAyBK,kCAAqCG,CAAC,EAGrE,EACR,CACD,CAEA,MAAa,IAAIH,EAAgC,CAChD,GAAI,CACH,MAAMC,EAAWX,EAAK,KAAK,KAAK,QAASY,EAAYF,CAAG,CAAC,EACnDI,EAASZ,EAAK,aAAa,EACjC,MAAMD,EAASE,EAAiBQ,CAAQ,EAAGG,CAAM,EACjD,MAAMC,EAAeD,EAAO,KAAK,EACjC,OAAOC,EAAgB,KAAK,MAAMA,EAAa,SAAS,CAAC,EAAU,MACpE,MAAE,CACD,MACD,CACD,CAEA,MAAa,IAAIL,EAA0B,CAC1C,MAAO,CAAC,CAAE,MAAM,KAAK,IAAIA,CAAG,CAC7B,CAEA,MAAa,MAAO,CACnB,GAAI,CACH,MAAMX,EAAG,MAAM,KAAK,QAAS,CAAE,UAAW,EAAK,CAAC,CACjD,OAAS,EAAP,CACDM,EAAO,MAAM,8DAA+D,CAAC,CAC9E,CACD,CAEA,MAAa,IAAIK,EAAQM,EAA4B,CACpD,GAAI,CACH,MAAML,EAAWX,EAAK,KAAK,KAAK,QAASY,EAAYF,CAAG,CAAC,EACnDO,EAAOf,EAAK,WAAW,EAC7B,OAAAe,EAAK,MAAM,KAAK,UAAUD,CAAK,CAAC,EAChCC,EAAK,IAAI,EACT,MAAMhB,EAASgB,EAAMb,EAAkBO,CAAQ,CAAC,EACzC,EACR,MAAE,CACD,MAAO,EACR,CACD,CACD,CAEA,SAASC,EAAeF,EAAgB,CACvC,OAAOH,EAAW,QAAQ,EAAE,OAAOG,EAAI,SAAS,CAAC,EAAE,OAAO,KAAK,CAChE","sourcesContent":["import fs from 'node:fs/promises'\nimport path from 'node:path'\nimport { pipeline } from 'node:stream/promises'\nimport zlib from 'node:zlib'\nimport { createReadStream, createWriteStream } from 'node:fs'\nimport { logger } from './logger.js'\nimport { hasProperties } from '../cli/utils/utils.js'\nimport { createHash } from 'node:crypto'\nimport type { FlashcoreAdapter } from '../types/index.js'\n\ninterface FlashcoreFileAdapterOptions {\n\tdataDir?: string\n}\n\nexport class FlashcoreFileAdapter<K = string, V = unknown> implements FlashcoreAdapter<K, V> {\n\tpublic readonly dataDir: string\n\n\tconstructor(options: FlashcoreFileAdapterOptions = {}) {\n\t\tthis.dataDir = options.dataDir ?? path.join(process.cwd(), '.robo', 'data')\n\t}\n\n\tpublic async clear(): Promise<boolean> {\n\t\ttry {\n\t\t\tawait fs.rm(this.dataDir, { recursive: true, force: true })\n\t\t\tawait fs.mkdir(this.dataDir, { recursive: true })\n\t\t\treturn true\n\t\t} catch {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tpublic async delete(key: K): Promise<boolean> {\n\t\ttry {\n\t\t\tconst fileName = path.join(this.dataDir, _getSafeKey(key))\n\t\t\tawait fs.unlink(fileName)\n\t\t\treturn true\n\t\t} catch (e) {\n\t\t\t// Warn about failures except ENOENT because that just means the key doesn't exist (normal)\n\t\t\tif (hasProperties<{ code: unknown }>(e, ['code']) && e.code !== 'ENOENT') {\n\t\t\t\tlogger.warn(`Failed to delete key \"${key}\" from Flashcore file adapter.`, e)\n\t\t\t}\n\n\t\t\treturn false\n\t\t}\n\t}\n\n\tpublic async get(key: K): Promise<V | undefined> {\n\t\ttry {\n\t\t\tconst fileName = path.join(this.dataDir, _getSafeKey(key))\n\t\t\tconst gunzip = zlib.createGunzip()\n\t\t\tawait pipeline(createReadStream(fileName), gunzip)\n\t\t\tconst decompressed = gunzip.read()\n\t\t\treturn decompressed ? (JSON.parse(decompressed.toString()) as V) : undefined\n\t\t} catch {\n\t\t\treturn undefined\n\t\t}\n\t}\n\n\tpublic async has(key: K): Promise<boolean> {\n\t\treturn !!(await this.get(key))\n\t}\n\n\tpublic async init() {\n\t\ttry {\n\t\t\tawait fs.mkdir(this.dataDir, { recursive: true })\n\t\t} catch (e) {\n\t\t\tlogger.error('Failed to create data directory for Flashcore file adapter.', e)\n\t\t}\n\t}\n\n\tpublic async set(key: K, value: V): Promise<boolean> {\n\t\ttry {\n\t\t\tconst fileName = path.join(this.dataDir, _getSafeKey(key))\n\t\t\tconst gzip = zlib.createGzip()\n\t\t\tgzip.write(JSON.stringify(value))\n\t\t\tgzip.end()\n\t\t\tawait pipeline(gzip, createWriteStream(fileName))\n\t\t\treturn true\n\t\t} catch {\n\t\t\treturn false\n\t\t}\n\t}\n}\n\nfunction _getSafeKey<K>(key: K): string {\n\treturn createHash('sha256').update(key.toString()).digest('hex')\n}\n"]}