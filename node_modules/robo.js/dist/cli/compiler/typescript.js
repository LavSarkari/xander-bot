import { IS_BUN_RUNTIME } from '../utils/runtime-utils.js';
import { compilerLogger } from '../utils/loggers.js';
import { existsSync } from 'node:fs';
import { readFile } from 'node:fs/promises';
import path from 'node:path';

let ts;
let transform;
await preloadTransformers();
function buildDeclarationFiles(tsOptions) {
  const options = {
    target: ts.ScriptTarget.Latest,
    rootDir: "src",
    outDir: ".robo/build",
    // Don't worry, TS auto normalizes this
    declaration: true,
    emitDeclarationOnly: true,
    moduleResolution: ts.ModuleResolutionKind.NodeNext,
    noEmit: false,
    skipLibCheck: true,
    ...tsOptions ?? {},
    incremental: false
  };
  const fileNames = ts.sys.readDirectory("src", [".ts", ".tsx"]);
  const program = ts.createProgram(fileNames, options);
  const emitResult = program.emit();
  const allDiagnostics = ts.getPreEmitDiagnostics(program).concat(emitResult.diagnostics);
  allDiagnostics.forEach((diagnostic) => {
    switch (diagnostic.category) {
      case ts.DiagnosticCategory.Error:
        compilerLogger.error(formatDiagnostic(diagnostic));
        break;
      case ts.DiagnosticCategory.Warning:
        compilerLogger.warn(formatDiagnostic(diagnostic));
        break;
      case ts.DiagnosticCategory.Message:
      case ts.DiagnosticCategory.Suggestion:
        compilerLogger.info(formatDiagnostic(diagnostic));
        break;
    }
  });
  if (emitResult.emitSkipped) {
    process.exit(1);
  }
}
async function getTypeScriptCompilerOptions() {
  const configFileName = path.join(process.cwd(), "tsconfig.json");
  const configFileContents = await readFile(configFileName, "utf8");
  const { config: tsconfig, error } = ts.parseConfigFileTextToJson(configFileName, configFileContents);
  if (error) {
    compilerLogger.error("Error parsing tsconfig.json:", error);
    process.exit(1);
  }
  const { options: tsOptions } = ts.convertCompilerOptionsFromJson(
    tsconfig.compilerOptions,
    path.dirname(configFileName)
  );
  if (tsOptions.errors) {
    compilerLogger.error("Error parsing compiler options from tsconfig.json");
    process.exit(1);
  }
  return tsOptions;
}
function formatDiagnostic(diagnostic) {
  if (diagnostic.file) {
    const { line, character } = ts.getLineAndCharacterOfPosition(diagnostic.file, diagnostic.start);
    const message = ts.flattenDiagnosticMessageText(diagnostic.messageText, "\n");
    return `${diagnostic.file.fileName} (${line + 1},${character + 1}): ${message}`;
  } else {
    return ts.flattenDiagnosticMessageText(diagnostic.messageText, "\n");
  }
}
function isTypescriptProject() {
  const missing = [];
  if (!existsSync(path.join(process.cwd(), "tsconfig.json"))) {
    missing.push("tsconfig.json");
  }
  if (typeof ts === "undefined") {
    missing.push("typescript");
  }
  if (typeof transform === "undefined") {
    missing.push("@swc/core");
  }
  return {
    isTypeScript: missing.length === 0,
    missing
  };
}
async function preloadTransformers() {
  try {
    if (!IS_BUN_RUNTIME) {
      compilerLogger.debug(`Preloading Typescript transformers...`);
      const [typescript, swc] = await Promise.all([import('typescript'), import('@swc/core')]);
      ts = typescript.default;
      transform = swc.transform;
    }
  } catch {
  }
}

export { buildDeclarationFiles, getTypeScriptCompilerOptions, isTypescriptProject, preloadTransformers, transform, ts };
